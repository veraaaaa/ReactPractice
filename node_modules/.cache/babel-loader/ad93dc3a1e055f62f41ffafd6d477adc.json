{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* tslint:disable:no-console */\nimport React, { Component } from 'react';\nimport { calcRotation, getEventName, now, calcMutliFingerStatus, calcMoveStatus, shouldTriggerSwipe, shouldTriggerDirection, getMovingDirection, getDirectionEventName } from './util';\nimport { PRESS, DIRECTION_ALL, DIRECTION_VERTICAL, DIRECTION_HORIZONTAL } from './config';\n;\n;\nvar directionMap = {\n  all: DIRECTION_ALL,\n  vertical: DIRECTION_VERTICAL,\n  horizontal: DIRECTION_HORIZONTAL\n};\nvar Gesture = function (_Component) {\n  _inherits(Gesture, _Component);\n  function Gesture(props) {\n    _classCallCheck(this, Gesture);\n    var _this = _possibleConstructorReturn(this, (Gesture.__proto__ || Object.getPrototypeOf(Gesture)).call(this, props));\n    _this.state = {};\n    _this.triggerEvent = function (name) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      var cb = _this.props[name];\n      if (typeof cb === 'function') {\n        // always give user gesture object as first params first\n        cb.apply(undefined, [_this.getGestureState()].concat(args));\n      }\n    };\n    _this.triggerCombineEvent = function (mainEventName, eventStatus) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n      _this.triggerEvent.apply(_this, [mainEventName].concat(args));\n      _this.triggerSubEvent.apply(_this, [mainEventName, eventStatus].concat(args));\n    };\n    _this.triggerSubEvent = function (mainEventName, eventStatus) {\n      for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n      if (eventStatus) {\n        var subEventName = getEventName(mainEventName, eventStatus);\n        _this.triggerEvent.apply(_this, [subEventName].concat(args));\n      }\n    };\n    _this.triggerPinchEvent = function (mainEventName, eventStatus) {\n      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n      var scale = _this.gesture.scale;\n      if (eventStatus === 'move' && typeof scale === 'number') {\n        if (scale > 1) {\n          _this.triggerEvent('onPinchOut');\n        }\n        if (scale < 1) {\n          _this.triggerEvent('onPinchIn');\n        }\n      }\n      _this.triggerCombineEvent.apply(_this, [mainEventName, eventStatus].concat(args));\n    };\n    _this.initPressTimer = function () {\n      _this.cleanPressTimer();\n      _this.pressTimer = setTimeout(function () {\n        _this.setGestureState({\n          press: true\n        });\n        _this.triggerEvent('onPress');\n      }, PRESS.time);\n    };\n    _this.cleanPressTimer = function () {\n      /* tslint:disable:no-unused-expression */\n      _this.pressTimer && clearTimeout(_this.pressTimer);\n    };\n    _this.setGestureState = function (params) {\n      if (!_this.gesture) {\n        _this.gesture = {};\n      }\n      // cache the previous touches\n      if (_this.gesture.touches) {\n        _this.gesture.preTouches = _this.gesture.touches;\n      }\n      _this.gesture = _extends({}, _this.gesture, params);\n    };\n    _this.getGestureState = function () {\n      if (!_this.gesture) {\n        return _this.gesture;\n      } else {\n        // shallow copy\n        return _extends({}, _this.gesture);\n      }\n    };\n    _this.cleanGestureState = function () {\n      delete _this.gesture;\n    };\n    _this.getTouches = function (e) {\n      return Array.prototype.slice.call(e.touches).map(function (item) {\n        return {\n          x: item.screenX,\n          y: item.screenY\n        };\n      });\n    };\n    _this.triggerUserCb = function (status, e) {\n      var cbName = getEventName('onTouch', status);\n      if (cbName in _this.props) {\n        _this.props[cbName](e);\n      }\n    };\n    _this._handleTouchStart = function (e) {\n      _this.triggerUserCb('start', e);\n      _this.event = e;\n      if (e.touches.length > 1) {\n        e.preventDefault();\n      }\n      _this.initGestureStatus(e);\n      _this.initPressTimer();\n      _this.checkIfMultiTouchStart();\n    };\n    _this.initGestureStatus = function (e) {\n      _this.cleanGestureState();\n      // store the gesture start state\n      var startTouches = _this.getTouches(e);\n      var startTime = now();\n      var startMutliFingerStatus = calcMutliFingerStatus(startTouches);\n      _this.setGestureState({\n        startTime: startTime,\n        startTouches: startTouches,\n        startMutliFingerStatus: startMutliFingerStatus,\n        /* copy for next time touch move cala convenient*/\n        time: startTime,\n        touches: startTouches,\n        mutliFingerStatus: startMutliFingerStatus,\n        srcEvent: _this.event\n      });\n    };\n    _this.checkIfMultiTouchStart = function () {\n      var _this$props = _this.props,\n        enablePinch = _this$props.enablePinch,\n        enableRotate = _this$props.enableRotate;\n      var touches = _this.gesture.touches;\n      if (touches.length > 1 && (enablePinch || enableRotate)) {\n        if (enablePinch) {\n          var startMutliFingerStatus = calcMutliFingerStatus(touches);\n          _this.setGestureState({\n            startMutliFingerStatus: startMutliFingerStatus,\n            /* init pinch status */\n            pinch: true,\n            scale: 1\n          });\n          _this.triggerCombineEvent('onPinch', 'start');\n        }\n        if (enableRotate) {\n          _this.setGestureState({\n            /* init rotate status */\n            rotate: true,\n            rotation: 0\n          });\n          _this.triggerCombineEvent('onRotate', 'start');\n        }\n      }\n    };\n    _this._handleTouchMove = function (e) {\n      _this.triggerUserCb('move', e);\n      _this.event = e;\n      if (!_this.gesture) {\n        // sometimes weird happen: touchstart -> touchmove..touchmove.. --> touchend --> touchmove --> touchend\n        // so we need to skip the unnormal event cycle after touchend\n        return;\n      }\n      // not a long press\n      _this.cleanPressTimer();\n      _this.updateGestureStatus(e);\n      _this.checkIfSingleTouchMove();\n      _this.checkIfMultiTouchMove();\n    };\n    _this.checkIfMultiTouchMove = function () {\n      var _this$gesture = _this.gesture,\n        pinch = _this$gesture.pinch,\n        rotate = _this$gesture.rotate,\n        touches = _this$gesture.touches,\n        startMutliFingerStatus = _this$gesture.startMutliFingerStatus,\n        mutliFingerStatus = _this$gesture.mutliFingerStatus;\n      if (!pinch && !rotate) {\n        return;\n      }\n      if (touches.length < 2) {\n        _this.setGestureState({\n          pinch: false,\n          rotate: false\n        });\n        // Todo: 2 finger -> 1 finger, wait to test this situation\n        pinch && _this.triggerCombineEvent('onPinch', 'cancel');\n        rotate && _this.triggerCombineEvent('onRotate', 'cancel');\n        return;\n      }\n      if (pinch) {\n        var scale = mutliFingerStatus.z / startMutliFingerStatus.z;\n        _this.setGestureState({\n          scale: scale\n        });\n        _this.triggerPinchEvent('onPinch', 'move');\n      }\n      if (rotate) {\n        var rotation = calcRotation(startMutliFingerStatus, mutliFingerStatus);\n        _this.setGestureState({\n          rotation: rotation\n        });\n        _this.triggerCombineEvent('onRotate', 'move');\n      }\n    };\n    _this.allowGesture = function () {\n      return shouldTriggerDirection(_this.gesture.direction, _this.directionSetting);\n    };\n    _this.checkIfSingleTouchMove = function () {\n      var _this$gesture2 = _this.gesture,\n        pan = _this$gesture2.pan,\n        touches = _this$gesture2.touches,\n        moveStatus = _this$gesture2.moveStatus,\n        preTouches = _this$gesture2.preTouches,\n        _this$gesture2$availa = _this$gesture2.availablePan,\n        availablePan = _this$gesture2$availa === undefined ? true : _this$gesture2$availa;\n      if (touches.length > 1) {\n        _this.setGestureState({\n          pan: false\n        });\n        // Todo: 1 finger -> 2 finger, wait to test this situation\n        pan && _this.triggerCombineEvent('onPan', 'cancel');\n        return;\n      }\n      // add avilablePan condition to fix the case in scrolling, which will cause unavailable pan move.\n      if (moveStatus && availablePan) {\n        var direction = getMovingDirection(preTouches[0], touches[0]);\n        _this.setGestureState({\n          direction: direction\n        });\n        var eventName = getDirectionEventName(direction);\n        if (!_this.allowGesture()) {\n          // if the first move is unavailable, then judge all of remaining touch movings are also invalid.\n          if (!pan) {\n            _this.setGestureState({\n              availablePan: false\n            });\n          }\n          return;\n        }\n        if (!pan) {\n          _this.triggerCombineEvent('onPan', 'start');\n          _this.setGestureState({\n            pan: true,\n            availablePan: true\n          });\n        } else {\n          _this.triggerCombineEvent('onPan', eventName);\n          _this.triggerSubEvent('onPan', 'move');\n        }\n      }\n    };\n    _this.checkIfMultiTouchEnd = function (status) {\n      var _this$gesture3 = _this.gesture,\n        pinch = _this$gesture3.pinch,\n        rotate = _this$gesture3.rotate;\n      if (pinch) {\n        _this.triggerCombineEvent('onPinch', status);\n      }\n      if (rotate) {\n        _this.triggerCombineEvent('onRotate', status);\n      }\n    };\n    _this.updateGestureStatus = function (e) {\n      var time = now();\n      _this.setGestureState({\n        time: time\n      });\n      if (!e.touches || !e.touches.length) {\n        return;\n      }\n      var _this$gesture4 = _this.gesture,\n        startTime = _this$gesture4.startTime,\n        startTouches = _this$gesture4.startTouches,\n        pinch = _this$gesture4.pinch,\n        rotate = _this$gesture4.rotate;\n      var touches = _this.getTouches(e);\n      var moveStatus = calcMoveStatus(startTouches, touches, time - startTime);\n      var mutliFingerStatus = void 0;\n      if (pinch || rotate) {\n        mutliFingerStatus = calcMutliFingerStatus(touches);\n      }\n      _this.setGestureState({\n        /* update status snapshot */\n        touches: touches,\n        mutliFingerStatus: mutliFingerStatus,\n        /* update duration status */\n        moveStatus: moveStatus\n      });\n    };\n    _this._handleTouchEnd = function (e) {\n      _this.triggerUserCb('end', e);\n      _this.event = e;\n      if (!_this.gesture) {\n        return;\n      }\n      _this.cleanPressTimer();\n      _this.updateGestureStatus(e);\n      _this.doSingleTouchEnd('end');\n      _this.checkIfMultiTouchEnd('end');\n    };\n    _this._handleTouchCancel = function (e) {\n      _this.triggerUserCb('cancel', e);\n      _this.event = e;\n      // Todo: wait to test cancel case\n      if (!_this.gesture) {\n        return;\n      }\n      _this.cleanPressTimer();\n      _this.updateGestureStatus(e);\n      _this.doSingleTouchEnd('cancel');\n      _this.checkIfMultiTouchEnd('cancel');\n    };\n    _this.triggerAllowEvent = function (type, status) {\n      if (_this.allowGesture()) {\n        _this.triggerCombineEvent(type, status);\n      } else {\n        _this.triggerSubEvent(type, status);\n      }\n    };\n    _this.doSingleTouchEnd = function (status) {\n      var _this$gesture5 = _this.gesture,\n        moveStatus = _this$gesture5.moveStatus,\n        pinch = _this$gesture5.pinch,\n        rotate = _this$gesture5.rotate,\n        press = _this$gesture5.press,\n        pan = _this$gesture5.pan,\n        direction = _this$gesture5.direction;\n      if (pinch || rotate) {\n        return;\n      }\n      if (moveStatus) {\n        var z = moveStatus.z,\n          velocity = moveStatus.velocity;\n        var swipe = shouldTriggerSwipe(z, velocity);\n        _this.setGestureState({\n          swipe: swipe\n        });\n        if (pan) {\n          // pan need end, it's a process\n          // sometimes, start with pan left, but end with pan right....\n          _this.triggerAllowEvent('onPan', status);\n        }\n        if (swipe) {\n          var directionEvName = getDirectionEventName(direction);\n          // swipe just need a direction, it's a endpoint\n          _this.triggerAllowEvent('onSwipe', directionEvName);\n          return;\n        }\n      }\n      if (press) {\n        _this.triggerEvent('onPressUp');\n        return;\n      }\n      _this.triggerEvent('onTap');\n    };\n    _this.getTouchAction = function () {\n      var _this$props2 = _this.props,\n        enablePinch = _this$props2.enablePinch,\n        enableRotate = _this$props2.enableRotate;\n      var directionSetting = _this.directionSetting;\n      if (enablePinch || enableRotate || directionSetting === DIRECTION_ALL) {\n        return 'pan-x pan-y';\n      }\n      if (directionSetting === DIRECTION_VERTICAL) {\n        return 'pan-x';\n      }\n      if (directionSetting === DIRECTION_HORIZONTAL) {\n        return 'pan-y';\n      }\n      return 'auto';\n    };\n    _this.directionSetting = directionMap[props.direction];\n    return _this;\n  }\n  _createClass(Gesture, [{\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.cleanPressTimer();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n      var child = React.Children.only(children);\n      var touchAction = this.getTouchAction();\n      var events = {\n        onTouchStart: this._handleTouchStart,\n        onTouchMove: this._handleTouchMove,\n        onTouchCancel: this._handleTouchCancel,\n        onTouchEnd: this._handleTouchEnd\n      };\n      return React.cloneElement(child, _extends({}, events, {\n        style: _extends({\n          touchAction: touchAction\n        }, child.props.style || {})\n      }));\n    }\n  }]);\n  return Gesture;\n}(Component);\nexport default Gesture;\nGesture.defaultProps = {\n  enableRotate: false,\n  enablePinch: false,\n  direction: 'all'\n};","map":{"version":3,"names":["_extends","_classCallCheck","_createClass","_possibleConstructorReturn","_inherits","React","Component","calcRotation","getEventName","now","calcMutliFingerStatus","calcMoveStatus","shouldTriggerSwipe","shouldTriggerDirection","getMovingDirection","getDirectionEventName","PRESS","DIRECTION_ALL","DIRECTION_VERTICAL","DIRECTION_HORIZONTAL","directionMap","all","vertical","horizontal","Gesture","_Component","props","_this","__proto__","Object","getPrototypeOf","call","state","triggerEvent","name","_len","arguments","length","args","Array","_key","cb","apply","undefined","getGestureState","concat","triggerCombineEvent","mainEventName","eventStatus","_len2","_key2","triggerSubEvent","_len3","_key3","subEventName","triggerPinchEvent","_len4","_key4","scale","gesture","initPressTimer","cleanPressTimer","pressTimer","setTimeout","setGestureState","press","time","clearTimeout","params","touches","preTouches","cleanGestureState","getTouches","e","prototype","slice","map","item","x","screenX","y","screenY","triggerUserCb","status","cbName","_handleTouchStart","event","preventDefault","initGestureStatus","checkIfMultiTouchStart","startTouches","startTime","startMutliFingerStatus","mutliFingerStatus","srcEvent","_this$props","enablePinch","enableRotate","pinch","rotate","rotation","_handleTouchMove","updateGestureStatus","checkIfSingleTouchMove","checkIfMultiTouchMove","_this$gesture","z","allowGesture","direction","directionSetting","_this$gesture2","pan","moveStatus","_this$gesture2$availa","availablePan","eventName","checkIfMultiTouchEnd","_this$gesture3","_this$gesture4","_handleTouchEnd","doSingleTouchEnd","_handleTouchCancel","triggerAllowEvent","type","_this$gesture5","velocity","swipe","directionEvName","getTouchAction","_this$props2","key","value","componentWillUnmount","render","children","child","Children","only","touchAction","events","onTouchStart","onTouchMove","onTouchCancel","onTouchEnd","cloneElement","style","defaultProps"],"sources":["/Users/vera/Downloads/千锋前端React项目教程（企业级实战开发）-源码笔记/11、跨组件状态控制/demoapp/node_modules/rc-gesture/es/index.js"],"sourcesContent":["import _extends from 'babel-runtime/helpers/extends';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* tslint:disable:no-console */\nimport React, { Component } from 'react';\nimport { calcRotation, getEventName, now, calcMutliFingerStatus, calcMoveStatus, shouldTriggerSwipe, shouldTriggerDirection, getMovingDirection, getDirectionEventName } from './util';\nimport { PRESS, DIRECTION_ALL, DIRECTION_VERTICAL, DIRECTION_HORIZONTAL } from './config';\n;\n;\nvar directionMap = {\n    all: DIRECTION_ALL,\n    vertical: DIRECTION_VERTICAL,\n    horizontal: DIRECTION_HORIZONTAL\n};\n\nvar Gesture = function (_Component) {\n    _inherits(Gesture, _Component);\n\n    function Gesture(props) {\n        _classCallCheck(this, Gesture);\n\n        var _this = _possibleConstructorReturn(this, (Gesture.__proto__ || Object.getPrototypeOf(Gesture)).call(this, props));\n\n        _this.state = {};\n        _this.triggerEvent = function (name) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            var cb = _this.props[name];\n            if (typeof cb === 'function') {\n                // always give user gesture object as first params first\n                cb.apply(undefined, [_this.getGestureState()].concat(args));\n            }\n        };\n        _this.triggerCombineEvent = function (mainEventName, eventStatus) {\n            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n                args[_key2 - 2] = arguments[_key2];\n            }\n\n            _this.triggerEvent.apply(_this, [mainEventName].concat(args));\n            _this.triggerSubEvent.apply(_this, [mainEventName, eventStatus].concat(args));\n        };\n        _this.triggerSubEvent = function (mainEventName, eventStatus) {\n            for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n                args[_key3 - 2] = arguments[_key3];\n            }\n\n            if (eventStatus) {\n                var subEventName = getEventName(mainEventName, eventStatus);\n                _this.triggerEvent.apply(_this, [subEventName].concat(args));\n            }\n        };\n        _this.triggerPinchEvent = function (mainEventName, eventStatus) {\n            for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n                args[_key4 - 2] = arguments[_key4];\n            }\n\n            var scale = _this.gesture.scale;\n\n            if (eventStatus === 'move' && typeof scale === 'number') {\n                if (scale > 1) {\n                    _this.triggerEvent('onPinchOut');\n                }\n                if (scale < 1) {\n                    _this.triggerEvent('onPinchIn');\n                }\n            }\n            _this.triggerCombineEvent.apply(_this, [mainEventName, eventStatus].concat(args));\n        };\n        _this.initPressTimer = function () {\n            _this.cleanPressTimer();\n            _this.pressTimer = setTimeout(function () {\n                _this.setGestureState({\n                    press: true\n                });\n                _this.triggerEvent('onPress');\n            }, PRESS.time);\n        };\n        _this.cleanPressTimer = function () {\n            /* tslint:disable:no-unused-expression */\n            _this.pressTimer && clearTimeout(_this.pressTimer);\n        };\n        _this.setGestureState = function (params) {\n            if (!_this.gesture) {\n                _this.gesture = {};\n            }\n            // cache the previous touches\n            if (_this.gesture.touches) {\n                _this.gesture.preTouches = _this.gesture.touches;\n            }\n            _this.gesture = _extends({}, _this.gesture, params);\n        };\n        _this.getGestureState = function () {\n            if (!_this.gesture) {\n                return _this.gesture;\n            } else {\n                // shallow copy\n                return _extends({}, _this.gesture);\n            }\n        };\n        _this.cleanGestureState = function () {\n            delete _this.gesture;\n        };\n        _this.getTouches = function (e) {\n            return Array.prototype.slice.call(e.touches).map(function (item) {\n                return {\n                    x: item.screenX,\n                    y: item.screenY\n                };\n            });\n        };\n        _this.triggerUserCb = function (status, e) {\n            var cbName = getEventName('onTouch', status);\n            if (cbName in _this.props) {\n                _this.props[cbName](e);\n            }\n        };\n        _this._handleTouchStart = function (e) {\n            _this.triggerUserCb('start', e);\n            _this.event = e;\n            if (e.touches.length > 1) {\n                e.preventDefault();\n            }\n            _this.initGestureStatus(e);\n            _this.initPressTimer();\n            _this.checkIfMultiTouchStart();\n        };\n        _this.initGestureStatus = function (e) {\n            _this.cleanGestureState();\n            // store the gesture start state\n            var startTouches = _this.getTouches(e);\n            var startTime = now();\n            var startMutliFingerStatus = calcMutliFingerStatus(startTouches);\n            _this.setGestureState({\n                startTime: startTime,\n                startTouches: startTouches,\n                startMutliFingerStatus: startMutliFingerStatus,\n                /* copy for next time touch move cala convenient*/\n                time: startTime,\n                touches: startTouches,\n                mutliFingerStatus: startMutliFingerStatus,\n                srcEvent: _this.event\n            });\n        };\n        _this.checkIfMultiTouchStart = function () {\n            var _this$props = _this.props,\n                enablePinch = _this$props.enablePinch,\n                enableRotate = _this$props.enableRotate;\n            var touches = _this.gesture.touches;\n\n            if (touches.length > 1 && (enablePinch || enableRotate)) {\n                if (enablePinch) {\n                    var startMutliFingerStatus = calcMutliFingerStatus(touches);\n                    _this.setGestureState({\n                        startMutliFingerStatus: startMutliFingerStatus,\n                        /* init pinch status */\n                        pinch: true,\n                        scale: 1\n                    });\n                    _this.triggerCombineEvent('onPinch', 'start');\n                }\n                if (enableRotate) {\n                    _this.setGestureState({\n                        /* init rotate status */\n                        rotate: true,\n                        rotation: 0\n                    });\n                    _this.triggerCombineEvent('onRotate', 'start');\n                }\n            }\n        };\n        _this._handleTouchMove = function (e) {\n            _this.triggerUserCb('move', e);\n            _this.event = e;\n            if (!_this.gesture) {\n                // sometimes weird happen: touchstart -> touchmove..touchmove.. --> touchend --> touchmove --> touchend\n                // so we need to skip the unnormal event cycle after touchend\n                return;\n            }\n            // not a long press\n            _this.cleanPressTimer();\n            _this.updateGestureStatus(e);\n            _this.checkIfSingleTouchMove();\n            _this.checkIfMultiTouchMove();\n        };\n        _this.checkIfMultiTouchMove = function () {\n            var _this$gesture = _this.gesture,\n                pinch = _this$gesture.pinch,\n                rotate = _this$gesture.rotate,\n                touches = _this$gesture.touches,\n                startMutliFingerStatus = _this$gesture.startMutliFingerStatus,\n                mutliFingerStatus = _this$gesture.mutliFingerStatus;\n\n            if (!pinch && !rotate) {\n                return;\n            }\n            if (touches.length < 2) {\n                _this.setGestureState({\n                    pinch: false,\n                    rotate: false\n                });\n                // Todo: 2 finger -> 1 finger, wait to test this situation\n                pinch && _this.triggerCombineEvent('onPinch', 'cancel');\n                rotate && _this.triggerCombineEvent('onRotate', 'cancel');\n                return;\n            }\n            if (pinch) {\n                var scale = mutliFingerStatus.z / startMutliFingerStatus.z;\n                _this.setGestureState({\n                    scale: scale\n                });\n                _this.triggerPinchEvent('onPinch', 'move');\n            }\n            if (rotate) {\n                var rotation = calcRotation(startMutliFingerStatus, mutliFingerStatus);\n                _this.setGestureState({\n                    rotation: rotation\n                });\n                _this.triggerCombineEvent('onRotate', 'move');\n            }\n        };\n        _this.allowGesture = function () {\n            return shouldTriggerDirection(_this.gesture.direction, _this.directionSetting);\n        };\n        _this.checkIfSingleTouchMove = function () {\n            var _this$gesture2 = _this.gesture,\n                pan = _this$gesture2.pan,\n                touches = _this$gesture2.touches,\n                moveStatus = _this$gesture2.moveStatus,\n                preTouches = _this$gesture2.preTouches,\n                _this$gesture2$availa = _this$gesture2.availablePan,\n                availablePan = _this$gesture2$availa === undefined ? true : _this$gesture2$availa;\n\n            if (touches.length > 1) {\n                _this.setGestureState({\n                    pan: false\n                });\n                // Todo: 1 finger -> 2 finger, wait to test this situation\n                pan && _this.triggerCombineEvent('onPan', 'cancel');\n                return;\n            }\n            // add avilablePan condition to fix the case in scrolling, which will cause unavailable pan move.\n            if (moveStatus && availablePan) {\n                var direction = getMovingDirection(preTouches[0], touches[0]);\n                _this.setGestureState({ direction: direction });\n                var eventName = getDirectionEventName(direction);\n                if (!_this.allowGesture()) {\n                    // if the first move is unavailable, then judge all of remaining touch movings are also invalid.\n                    if (!pan) {\n                        _this.setGestureState({ availablePan: false });\n                    }\n                    return;\n                }\n                if (!pan) {\n                    _this.triggerCombineEvent('onPan', 'start');\n                    _this.setGestureState({\n                        pan: true,\n                        availablePan: true\n                    });\n                } else {\n                    _this.triggerCombineEvent('onPan', eventName);\n                    _this.triggerSubEvent('onPan', 'move');\n                }\n            }\n        };\n        _this.checkIfMultiTouchEnd = function (status) {\n            var _this$gesture3 = _this.gesture,\n                pinch = _this$gesture3.pinch,\n                rotate = _this$gesture3.rotate;\n\n            if (pinch) {\n                _this.triggerCombineEvent('onPinch', status);\n            }\n            if (rotate) {\n                _this.triggerCombineEvent('onRotate', status);\n            }\n        };\n        _this.updateGestureStatus = function (e) {\n            var time = now();\n            _this.setGestureState({\n                time: time\n            });\n            if (!e.touches || !e.touches.length) {\n                return;\n            }\n            var _this$gesture4 = _this.gesture,\n                startTime = _this$gesture4.startTime,\n                startTouches = _this$gesture4.startTouches,\n                pinch = _this$gesture4.pinch,\n                rotate = _this$gesture4.rotate;\n\n            var touches = _this.getTouches(e);\n            var moveStatus = calcMoveStatus(startTouches, touches, time - startTime);\n            var mutliFingerStatus = void 0;\n            if (pinch || rotate) {\n                mutliFingerStatus = calcMutliFingerStatus(touches);\n            }\n            _this.setGestureState({\n                /* update status snapshot */\n                touches: touches,\n                mutliFingerStatus: mutliFingerStatus,\n                /* update duration status */\n                moveStatus: moveStatus\n            });\n        };\n        _this._handleTouchEnd = function (e) {\n            _this.triggerUserCb('end', e);\n            _this.event = e;\n            if (!_this.gesture) {\n                return;\n            }\n            _this.cleanPressTimer();\n            _this.updateGestureStatus(e);\n            _this.doSingleTouchEnd('end');\n            _this.checkIfMultiTouchEnd('end');\n        };\n        _this._handleTouchCancel = function (e) {\n            _this.triggerUserCb('cancel', e);\n            _this.event = e;\n            // Todo: wait to test cancel case\n            if (!_this.gesture) {\n                return;\n            }\n            _this.cleanPressTimer();\n            _this.updateGestureStatus(e);\n            _this.doSingleTouchEnd('cancel');\n            _this.checkIfMultiTouchEnd('cancel');\n        };\n        _this.triggerAllowEvent = function (type, status) {\n            if (_this.allowGesture()) {\n                _this.triggerCombineEvent(type, status);\n            } else {\n                _this.triggerSubEvent(type, status);\n            }\n        };\n        _this.doSingleTouchEnd = function (status) {\n            var _this$gesture5 = _this.gesture,\n                moveStatus = _this$gesture5.moveStatus,\n                pinch = _this$gesture5.pinch,\n                rotate = _this$gesture5.rotate,\n                press = _this$gesture5.press,\n                pan = _this$gesture5.pan,\n                direction = _this$gesture5.direction;\n\n            if (pinch || rotate) {\n                return;\n            }\n            if (moveStatus) {\n                var z = moveStatus.z,\n                    velocity = moveStatus.velocity;\n\n                var swipe = shouldTriggerSwipe(z, velocity);\n                _this.setGestureState({\n                    swipe: swipe\n                });\n                if (pan) {\n                    // pan need end, it's a process\n                    // sometimes, start with pan left, but end with pan right....\n                    _this.triggerAllowEvent('onPan', status);\n                }\n                if (swipe) {\n                    var directionEvName = getDirectionEventName(direction);\n                    // swipe just need a direction, it's a endpoint\n                    _this.triggerAllowEvent('onSwipe', directionEvName);\n                    return;\n                }\n            }\n            if (press) {\n                _this.triggerEvent('onPressUp');\n                return;\n            }\n            _this.triggerEvent('onTap');\n        };\n        _this.getTouchAction = function () {\n            var _this$props2 = _this.props,\n                enablePinch = _this$props2.enablePinch,\n                enableRotate = _this$props2.enableRotate;\n            var directionSetting = _this.directionSetting;\n\n            if (enablePinch || enableRotate || directionSetting === DIRECTION_ALL) {\n                return 'pan-x pan-y';\n            }\n            if (directionSetting === DIRECTION_VERTICAL) {\n                return 'pan-x';\n            }\n            if (directionSetting === DIRECTION_HORIZONTAL) {\n                return 'pan-y';\n            }\n            return 'auto';\n        };\n        _this.directionSetting = directionMap[props.direction];\n        return _this;\n    }\n\n    _createClass(Gesture, [{\n        key: 'componentWillUnmount',\n        value: function componentWillUnmount() {\n            this.cleanPressTimer();\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            var children = this.props.children;\n\n            var child = React.Children.only(children);\n            var touchAction = this.getTouchAction();\n            var events = {\n                onTouchStart: this._handleTouchStart,\n                onTouchMove: this._handleTouchMove,\n                onTouchCancel: this._handleTouchCancel,\n                onTouchEnd: this._handleTouchEnd\n            };\n            return React.cloneElement(child, _extends({}, events, { style: _extends({ touchAction: touchAction }, child.props.style || {}) }));\n        }\n    }]);\n\n    return Gesture;\n}(Component);\n\nexport default Gesture;\n\nGesture.defaultProps = {\n    enableRotate: false,\n    enablePinch: false,\n    direction: 'all'\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}